# 哈希表的实现

## 哈希函数

### 快速的计算

**1.** 好的哈希函数应该尽可能让计算的过程变得简单, 应该可以快速计算出结果.

- **1.1** 哈希表的主要优点是它的速度, 所以在速度上不能满足, 那么就达不到设计的目的了.
  
- **1.2** 提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法. 因为它们的性能是比较低的.

**2.** 在前面, 我们计算哈希值的时候使用的方式

- **2.1** cats = 3*27³+1*27²+20*27+17= 60337
- **2.2** 这种方式是直观的计算结果, 那么这种计算方式会进行几次乘法几次加法呢? 当然, 我们可能不止4项, 可能有更多项
- **2.3** 我们抽象一下, 这个表达式其实是一个多项式: a(n)xn+a(n-1)x(n-1)+…+a(1)x+a(0)
- **2.4** 现在问题就变成了多项式有多少次乘法和加法:
  - **2.4.1** 乘法次数: n＋(n－1)＋…＋1＝n(n+1)/2
  - **2.4.2** 加法次数: n次

**3.** 多项式的优化: 霍纳法则

- **3.1** 解决这类求值问题的高效算法――霍纳法则。在中国，霍纳法则也被称为秦九韶算法。
- **3.2** 通过如下变换我们可以得到一种快得多的算法，即Pn(x)= anx n+a(n－1)x(n-1)+…+a1x+a0=((…(((anx +an－1)x+an－2)x+ an－3)…)x+a1)x+a0，这种求值的安排我们称为霍纳法则。
- **3.3** 变换后, 我们需要多少次乘法, 多少次加法呢?
  - **3.3.1** 乘法次数: N次
  - **3.3.2** 加法次数: N次.
  - **3.4** 如果使用大O表示时间复杂度的话, 我们直接从O(N²)降到了O(N).

### 均匀的分布

> 均匀的分布:

- 在设计哈希表时, 我们已经有办法处理映射到相同下标值的情况: 链地址法或者开放地址法.
- 但是, 为了提供效率, 最好的情况还是让数据在哈希表中均匀分布.
- 因此, 我们需要在使用常量的地方, 尽量使用质数.
- 哪些地方我们会使用到常量呢?

> 质数的使用:

- 哈希表的长度.
- N次幂的底数(我们之前使用的是27)
- 下面我们简单来说一下为什么.

> 哈希表的长度使用质数:

**1.** 这个在链地址法中事实上重要性不是特别明显, 明显的是在开放地址法中的再哈希法中.

**2.** 再哈希法中质数的重要性:

- **2.1** 假设表的容量不是质数, 例如: 表长为15(下标值0~14)
- **2.2** 有一个特定关键字映射到0, 步长为5. 探测序列是多少呢?
- **2.3** 0 - 5 - 10 - 0 - 5 - 10, 依次类推, 循环下去.
- **2.4** 算法只尝试着三个单元, 如果这三个单元已经有了数据, 那么会一直循环下去, 知道程序崩溃.
- **2.5** 如果容量是一个质数, 比如13. 探测序列是多少呢?
- **2.6** 0 - 5 - 10 - 2 - 7 - 12 - 4 - 9 - 1 - 6 - 11 - 3, 一直这样下去.
- **2.7** 不仅不会产生循环, 而且可以让数据在哈希表中更加均匀的分布.

**3.** 链地址法中质数没有那么重要, 甚至在Java中故意是2的N次幂

- **3.1** Java中的哈希表采用的是链地址法.
- **3.2** HashMap的初始长度是16, 每次自动扩展(我们还没有聊到扩展的话题), 长度必须是2的次幂.
- **3.3** 这是为了服务于从Key映射到index的算法.
- **3.4** HashMap中为了提高效率, 采用了位运算的方式.
  - **3.4.1** HashMap中index的计算公式: index = HashCode（Key） & （Length - 1）
  - **3.4.2** 比如计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001
  - **3.4.3** 假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111
  - **3.4.4** 假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111
  - **3.4.5** 把以上两个结果做与运算，101110001110101110 1001 & 1111 = 1001，十进制是9，所以 index=9
  - **3.4.6** 这样的方式相对于取模来说性能是高的, 因为计算机更运算计算二进制的数据.
- **3.5** 但是, 我个人发现JavaScript中进行较大数据的位运算时会出问题, 所以我的代码实现中还是使用了取模.

> N次幂的底数, 使用质数:

- 这里采用质数的原因是为了产生的数据不按照某种规律递增.
- 比如我们这里有一组数据是按照4进行递增的: 0 4 8 12 16, 将其映射到成都为8的哈希表中.
- 它们的位置是多少呢? 0 - 4 - 0 - 4, 依次类推.
- 如果我们哈希表本身不是质数, 而我们递增的数量可以使用质数, 比如5, 那么 0 5 10 15 20
- 它们的位置是多少呢? 0 - 5 - 2 - 7 - 4, 依次类推. 也可以尽量让数据均匀的分布.
- 我们之前使用的是27, 这次可以使用一个接近的数, 比如31/37/41等等. 一个比较常用的数是37.